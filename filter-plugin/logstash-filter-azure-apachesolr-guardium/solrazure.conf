input 
{
  beats 
  {
  port => <Port-Number> #ex. 5085
  type => "solr_azure"
  }
}
filter{
if [type] == "solr_azure" and "apache_solr_on_azure" == [tags][0]{
  mutate {
    add_field => { "server_ip" => "%{[host][ip][0]}" } 
	add_field => { "server_os" => "%{[host][os][name]}" }
	add_field => { "serverHostName" => "%{[host][hostname]}" }	
	}
if "o.a.s.u.p.LogUpdateProcessorFactory" in [mes***REMOVED***ge] {
grok {
match => {"mes***REMOVED***ge" => "%{TIMESTAMP_ISO8601:timestamp}\s%{LOGLEVEL:event_type}\s\s(?<logtype>[^\s]*)\s\[\s*(?<collection>[^\]]*)\]\s(?<class_name>[^\s]*)\s\[(?<core>[^\s\]]*)\]\s\s(?<app_type>[^\s]*)=(?<app_value>[^\s]*)\s(?<path_type>[^\s]*)=(?<path_value>[^\s]*) (?<query_type>[^{]*)%{GREEDYDATA:query_value} %{INT:constant} %{NUMBER:interval}"
}
}
}
else if "o.a.s.c.S.Request" in [mes***REMOVED***ge] and "path=/select" in [mes***REMOVED***ge] or "path=/query" in [mes***REMOVED***ge] or "path=/terms" in [mes***REMOVED***ge] or "path=/get" in [mes***REMOVED***ge] and "params={distrib=false" not in [mes***REMOVED***ge] or "path=/spell" in [mes***REMOVED***ge] or "path=/export" in [mes***REMOVED***ge] or "o.a.s.s.HttpSolrCall" in [mes***REMOVED***ge]
{
grok {
match => {"mes***REMOVED***ge" => ["%{TIMESTAMP_ISO8601:timestamp}\s%{LOGLEVEL:event_type}\s\s(?<logtype>[^\s]*)\s\[\s*(?<collection>[^\]]*)\]\s(?<class_name>[^\s]*)\s\[(?<core>[^\s\]]*)\]\s*(?<app_type>[^\s]*)=(?<app_value>[^\s]*)\s(?<path_type>[^\s]*)=(?<path_value>[^\s]*) (?<query_type>[^{]*)%{DATA:query_value}\s%{GREEDYDATA:executionvalues}"
]
}
}
}
else
{
grok {
match => {"mes***REMOVED***ge" => [
"%{TIMESTAMP_ISO8601:timestamp}\s%{LOGLEVEL:event_type}\s(?<logtype>[^\s]*)\s\[\s*(?<collection>[^\]]*)\]\s%{GREEDYDATA:error_value}"
]
}
}
}
if "_grokparsefailure"  in [tags]{
drop { }
    }
apache_solr_azure_connector {}
}
}
output{
stdout{ codec => rubydebug }
}