#
# Copyright 2021-2022 IBM Inc. All rights reserved
# SPDX-License-Identifier: Apache2.0
#
filter {
    if [type] == "filebeat" and "guc_filter_param_datasource_tag" in [tags] {
        if [mes***REMOVED***ge] =~ /LOG/ and [mes***REMOVED***ge] !~ /AUDIT/ {
            drop { }
        }

        # Dorpping the loglines contains the queries for pg_catalog schema and other variable setting queries
        # fired by client application.
        if [mes***REMOVED***ge] =~ /(?i)(from\s+)?pg_catalog|search_path|application_name|current_schema|session_user|TRANSACTION\s+ISOLATION\s+LEVEL|extra_float_digits/ {
            drop { }
        }

        # Dorpping the loglines contains the queries for information_schema schema
        if [mes***REMOVED***ge] =~ /(?i)(from\s+)?information_schema/ {
            drop { }
        }

        if [mes***REMOVED***ge] !~ /(?i)(AUDIT:|ERROR:|STATEMENT:|FATAL:|DETAIL:)/ {
            drop { }
        }

        mutate {
            gsub => ["mes***REMOVED***ge", "\t", " "]
        }

        grok {
            match => {
                # Matching for NoSQL events
                # The regex starts looking from the word AUDIT in the log event. It will extract the required data by
                # ***REMOVED***perating the log logline by pipe symbol (|)
                "mes***REMOVED***ge" => "(.*)AUDIT:[\s\t]+(user:%{USERNAME:username}\|)(host:%{IPORHOST:server_ip}:%{INT:server_port}\|)(source:%{IPORHOST:client_ip}\|)(port:%{INT:client_port}\|)(timestamp:%{NUMBER:timestamp}\|)(type:%{WORD:event_type}\|)(category:%{WORD:event_category}\|)(ks:%{WORD:db_name}\|)?(scope:%{WORD:entity_name}\|)?(operation:(?<query>[^;]*);*)[\s\t]*(?<error_description>.*)?"
            }
            tag_on_failure => ["sql_event"]
        }

        if "sql_event" in [tags] {
            grok {
                # The regex search begins from the matching timestamp in the log event. It will extract the
                # required data by separating the log logline initially by spaces or tabs up to occurrence of the
                # word "AUDIT", and then later it will look for the commas as a separator.
                match => {
                  "mes***REMOVED***ge" => "(%{NUMBER:timestamp}[\t\s]+)(%{IP:client_ip})\(%{NUMBER:client_port}\)[\t\s]+\[(%{NUMBER:process_id})\][\t\s]+(%{GREEDYDATA:application_name})[\t\s]+(%{USERNAME:username})[\t\s]+(%{WORD:db_name})[\t\s]+(?<session_id>%{BASE16NUM}.%{BASE16NUM})[\t\s]+(%{NUMBER:tra***REMOVED***ction_id})[\s\t]+(%{WORD:event_category}):[ \t]+AUDIT:[\s\t]+(?<audit_type>SESSION|OBJECT),(%{INT:statement_id}),(%{INT:sub_statement_id}),(%{WORD:event_category}),(?<event_type>[A-Z\***REMOVED***-z]*),(?<object_type>([A-Z.a-z\s]*)),(?<object_name>([^,]*)),(%{GREEDYDATA:query}),(%{GREEDYDATA:parameters})"
                }
                tag_on_failure => ["sql_error_event"]
            }
        }

        if "sql_error_event" in [tags] {
            mutate {
                remove_tag => [ "sql_event" ]
            }

            # Matching for SQL Error events
            if [mes***REMOVED***ge] =~ /(?i)authentication(\s+)failed(\s+)for(\s+)user/ {
                # Error logs containing authentication failed mes***REMOVED***ge, Example, password authentication failed for user "foo"
                # the regex looks for the sequence of the workds "authentication failed for user"
                grok {
                    match => {
                        "mes***REMOVED***ge" => "FATAL:[\s\t]+(?<error_fatal>(.*))[\s\t]+(%{NUMBER:timestamp}[\s\t]+)(%{IP:client_ip}[\s\t]*)\(%{NUMBER:client_port}\)[\s\t]+\[(%{NUMBER:process_id})\][\s\t]+(%{GREEDYDATA:application_name})[\s\t]+(%{USERNAME:username})[\s\t]+(%{WORD:db_name})[\s\t]+(?<session_id>%{BASE16NUM}.%{BASE16NUM})[\s\t]+(%{NUMBER:tra***REMOVED***ction_id})[\s\t]+DETAIL:[\s\t]+(?<error_detail>.*?\.)"
                    }
                    add_field => {
                        error_description => "%{error_fatal}. %{error_detail}"
                        event_type => "AUTH_ERROR"
                    }
                    remove_field => ["error_fatal", "error_detail"]
                }
            } else if [mes***REMOVED***ge] =~ /(?i)((role|user).*does\s+not\s+exist)/{
                # Fatal logs for authentication failed issue other then password authentication. For example, Role not found
                # the regex looks for the keyword "Fatal", refer the documentation here,
                # https://www.postgresql.org/docs/current/client-authentication-problems.html
                grok {
                    match => {
                        "mes***REMOVED***ge" => "(%{NUMBER:timestamp}[\s\t]+)(%{IP:client_ip}[\s\t]*)\(%{NUMBER:client_port}\)[\s\t]+\[(%{NUMBER:process_id})\][\s\t]+(%{GREEDYDATA:application_name})[\s\t]+(%{USERNAME:username})[\s\t]+(%{WORD:db_name})[\s\t]+(?<session_id>%{BASE16NUM}.%{BASE16NUM})[\s\t]+(%{NUMBER:tra***REMOVED***ction_id})[\s\t]+(FATAL:)[\s\t]+(%{GREEDYDATA:error_description}[\s\t]*)"
                    }
                    add_field => {
                        event_type => "AUTH_ERROR"
                    }
                }
            } else if [mes***REMOVED***ge] =~ /STATEMENT:/ {
                # Error logs containing the lastly fired query, Example, Table not found error
                # The regex starts looking from the matching timestamp in the log event. It will extract the
                # required data by ***REMOVED***perating the log logline initially by spaces or tabs up to occurance of the
                # word "STATEMENT" and then later, the text will be considered as fired query.
                grok {
                    match => {
                        "mes***REMOVED***ge" => "(%{NUMBER:timestamp}[\s\t]+)(%{IP:client_ip}[\s\t]*)\(%{NUMBER:client_port}\)[\s\t]+\[(%{NUMBER:process_id})\][\s\t]+(%{GREEDYDATA:application_name})[\s\t]+(%{USERNAME:username})[\s\t]+(%{WORD:db_name})[\s\t]+(?<session_id>%{BASE16NUM}.%{BASE16NUM})[\s\t]+(%{NUMBER:tra***REMOVED***ction_id})[\s\t]+(ERROR:)[\s\t]+(%{GREEDYDATA:error_description}[\s\t]+)(%{NUMBER}[\s\t]+)(%{IP})\(%{NUMBER}\)[\s\t]+\[(%{NUMBER})\][\s\t]+(%{GREEDYDATA})[\s\t]+(%{USERNAME})[\s\t]+(%{WORD})[\s\t]+(%{BASE16NUM}.%{BASE16NUM})[\s\t]+(%{NUMBER})[\s\t]+(STATEMENT:)[\t\s]+(%{GREEDYDATA:query})"
                    }
                    add_field => {
                        event_type => "SQL_ERROR"
                    }
                }
            } else {
                # Error logs containing only error mes***REMOVED***ges, Example, Syntax errors
                # the regex looks for the keyword "Error"
                grok {
                    match => {
                        "mes***REMOVED***ge" => "(%{NUMBER:timestamp}[\s\t]+)(%{IP:client_ip}[\s\t]*)\(%{NUMBER:client_port}\)[\s\t]+\[(%{NUMBER:process_id})\][\s\t]+(%{GREEDYDATA:application_name})[\s\t]+(%{USERNAME:username})[\s\t]+(%{WORD:db_name})[\s\t]+(?<session_id>%{BASE16NUM}.%{BASE16NUM})[\s\t]+(%{NUMBER:tra***REMOVED***ction_id})[\s\t]+(ERROR:|FATAL:)[\s\t]+(%{GREEDYDATA:error_description}[\s\t]*)"
                    }
                    add_field => {
                        event_type => "SQL_ERROR"
                    }
                }
            }
        }

        if "sql_event" in [tags] or "sql_error_event" in [tags] {
            mutate {
                add_field => {
                    "log_type" => "sql"
                }
            }
        }

        mutate {
            add_field => {
                "serverHost" => "%{[host][name]}"
                "serverOS" => "%{[host][os][name]}"
                "serverIP" => "%%{[host][ip][0]}"
            }
        }


        if "_grokparsefailure" in [tags] {
            drop { }
        }

        yugabytedb_guardium_filter{}

        mutate {
            remove_tag => ["sql_event" , "sql_error_event"]
        }

        prune {
            whitelist_names => [ "GuardRecord" ]
        }
    }
}
