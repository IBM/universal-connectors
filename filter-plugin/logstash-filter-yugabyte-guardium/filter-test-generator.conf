#
# Copyright 2021-2022 IBM Inc. All rights reserved
# SPDX-License-Identifier: Apache2.0
#

input {
     generator {
         lines => [
            "I1223 08:28:19.383865   348 audit_logger.cc:533] AUDIT: user:cassandra|host:172.17.0.2:9042|source:172.17.0.1|port:63396|timestamp:1671784125000|type:LOGIN_SUCCESS|category:AUTH|operation:LOGIN SUCCESSFUL",
            "I1223 08:28:19.474006   357 audit_logger.cc:533] AUDIT: user:cassandra|host:172.17.0.2:9042|source:172.17.0.1|port:63398|timestamp:1671784125000|type:LOGIN_SUCCESS|category:AUTH|operation:LOGIN SUCCESSFUL",
            "I1223 08:32:04.290328   355 audit_logger.cc:533] AUDIT: user:cassandra|host:172.17.0.2:9042|source:172.17.0.1|port:63398|timestamp:1671784125000|type:CREATE_KEYSPACE|category:DDL|ks:example|operation:CREATE KEYSPACE example;",
            "I1223 08:32:10.719689   355 audit_logger.cc:533] AUDIT: user:cassandra|host:172.17.0.2:9042|source:172.17.0.1|port:63398|timestamp:1671784125000|type:REQUEST_FAILURE|category:ERROR|operation:CREATE TABLE items(supplier_id INT,                                   item_id INT,                                   supplier_name TEXT STATIC,                                   item_name TEXT,                                   PRIMARY KEY((supplier_id), item_id));; No Namespace Used",
            "I1223 08:32:23.615161   348 audit_logger.cc:533] AUDIT: user:cassandra|host:172.17.0.2:9042|source:172.17.0.1|port:63398|timestamp:1671784125000|type:REQUEST_FAILURE|category:ERROR|operation:CREATE TABLE devices(supplier_id INT,                                     device_id INT,                                     model_year INT,                                     device_name TEXT,                                     PRIMARY KEY((supplier_id, device_id), model_year));; No Namespace Used"
         ]
         type => "filebeat"
         tags => ["Yugabyte"]
         count => 1
     }
}

filter {
    if [type] == "filebeat" and "Yugabyte" in [tags] {
        if [message] =~ /LOG/ and [message] !~ /AUDIT/ {
            drop { }
        }

        # Dorpping the loglines contains the queries for pg_catalog schema
        if [message] =~ /(?i)(from\s+)?pg_catalog|search_path|application_name|current_schema|session_user|TRANSACTION\s+ISOLATION\s+LEVEL|extra_float_digits/ {
            drop { }
        }

        # Dorpping the loglines contains the queries for information_schema schema
        if [message] =~ /(?i)(from\s+)?information_schema/ {
            drop { }
        }

        if [message] !~ /(?i)(AUDIT:|ERROR:|STATEMENT:|FATAL:|DETAIL:)/ {
            drop { }
        }

        mutate {
            gsub => ["message", "\t", " "]
        }

        grok {
            match => {
                # Matching for NoSQL events
                # The regex starts looking from the word AUDIT in the log event. It will extract the required data by
                # saperating the log logline by pipe symbol (|)
                "message" => "(.*)AUDIT:[\s\t]+(user:%{USERNAME:username}\|)(host:%{IPORHOST:server_ip}:%{INT:server_port}\|)(source:%{IPORHOST:client_ip}\|)(port:%{INT:client_port}\|)(timestamp:%{NUMBER:timestamp}\|)(type:%{WORD:event_type}\|)(category:%{WORD:event_category}\|)(ks:%{WORD:db_name}\|)?(scope:%{WORD:entity_name}\|)?(operation:(?<query>[^;]*);*)[\s\t]*(?<error_description>.*)?"
            }
            tag_on_failure => ["sql_event"]
        }

        if "sql_event" in [tags] {
            grok {
                # The regex search begins from the matching timestamp in the log event. It will extract the
                # required data by separating the log logline initially by spaces or tabs up to occurrence of the
                # word "AUDIT", and then later it will look for the commas as a separator.
                match => {
                  "message" => "(%{NUMBER:timestamp}[\t\s]+)(%{IP:client_ip})\(%{NUMBER:client_port}\)[\t\s]+\[(%{NUMBER:process_id})\][\t\s]+(%{GREEDYDATA:application_name})[\t\s]+(%{USERNAME:username})[\t\s]+(%{WORD:db_name})[\t\s]+(?<session_id>%{BASE16NUM}.%{BASE16NUM})[\t\s]+(%{NUMBER:trasaction_id})[\s\t]+(%{WORD:event_category}):[ \t]+AUDIT:[\s\t]+(?<audit_type>SESSION|OBJECT),(%{INT:statement_id}),(%{INT:sub_statement_id}),(%{WORD:event_category}),(?<event_type>[A-Z\sa-z]*),(?<object_type>([A-Z.a-z\s]*)),(?<object_name>([^,]*)),(%{GREEDYDATA:query}),(%{GREEDYDATA:parameters})"
                }
                tag_on_failure => ["sql_error_event"]
            }
        }

        if "sql_error_event" in [tags] {
            mutate {
                remove_tag => [ "sql_event" ]
            }

            # Matching for SQL Error events
            if [message] =~ /(?i)authentication(\s+)failed(\s+)for(\s+)user/ {
                # Error logs containing authentication failed message, Example, password authentication failed for user "foo"
                # the regex looks for the sequence of the workds "authentication failed for user"
                grok {
                    match => {
                        "message" => "FATAL:[\s\t]+(?<error_fatal>(.*))[\s\t]+(%{NUMBER:timestamp}[\s\t]+)(%{IP:client_ip}[\s\t]*)\(%{NUMBER:client_port}\)[\s\t]+\[(%{NUMBER:process_id})\][\s\t]+(%{GREEDYDATA:application_name})[\s\t]+(%{USERNAME:username})[\s\t]+(%{WORD:db_name})[\s\t]+(?<session_id>%{BASE16NUM}.%{BASE16NUM})[\s\t]+(%{NUMBER:trasaction_id})[\s\t]+DETAIL:[\s\t]+(?<error_detail>.*?\.)"
                    }
                    add_field => {
                        error_description => "%{error_fatal}. %{error_detail}"
                        event_type => "AUTH_ERROR"
                    }
                    remove_field => ["error_fatal", "error_detail"]
                }
            } else if [message] =~ /(?i)((role|user).*does\s+not\s+exist)/{
                # Fatal logs for authentication failed issue other then password authentication. For example, Role not found
                # the regex looks for the keyword "Fatal", refer the documentation here,
                # https://www.postgresql.org/docs/current/client-authentication-problems.html
                grok {
                    match => {
                        "message" => "(%{NUMBER:timestamp}[\s\t]+)(%{IP:client_ip}[\s\t]*)\(%{NUMBER:client_port}\)[\s\t]+\[(%{NUMBER:process_id})\][\s\t]+(%{GREEDYDATA:application_name})[\s\t]+(%{USERNAME:username})[\s\t]+(%{WORD:db_name})[\s\t]+(?<session_id>%{BASE16NUM}.%{BASE16NUM})[\s\t]+(%{NUMBER:trasaction_id})[\s\t]+(FATAL:)[\s\t]+(%{GREEDYDATA:error_description}[\s\t]*)"
                    }
                    add_field => {
                        event_type => "AUTH_ERROR"
                    }
                }
            } else if [message] =~ /STATEMENT:/ {
                # Error logs containing the lastly fired query, Example, Table not found error
                # The regex starts looking from the matching timestamp in the log event. It will extract the
                # required data by saperating the log logline initially by spaces or tabs up to occurance of the
                # word "STATEMENT" and then later, the text will be considered as fired query.
                grok {
                    match => {
                        "message" => "(%{NUMBER:timestamp}[\s\t]+)(%{IP:client_ip}[\s\t]*)\(%{NUMBER:client_port}\)[\s\t]+\[(%{NUMBER:process_id})\][\s\t]+(%{GREEDYDATA:application_name})[\s\t]+(%{USERNAME:username})[\s\t]+(%{WORD:db_name})[\s\t]+(?<session_id>%{BASE16NUM}.%{BASE16NUM})[\s\t]+(%{NUMBER:trasaction_id})[\s\t]+(ERROR:)[\s\t]+(%{GREEDYDATA:error_description}[\s\t]+)(%{NUMBER}[\s\t]+)(%{IP})\(%{NUMBER}\)[\s\t]+\[(%{NUMBER})\][\s\t]+(%{GREEDYDATA})[\s\t]+(%{USERNAME})[\s\t]+(%{WORD})[\s\t]+(%{BASE16NUM}.%{BASE16NUM})[\s\t]+(%{NUMBER})[\s\t]+(STATEMENT:)[\t\s]+(%{GREEDYDATA:query})"
                    }
                    add_field => {
                        event_type => "SQL_ERROR"
                    }
                }
            } else {
                # Error logs containing only error messages, Example, Syntax errors
                # the regex looks for the keyword "Error"
                grok {
                    match => {
                        "message" => "(%{NUMBER:timestamp}[\s\t]+)(%{IP:client_ip}[\s\t]*)\(%{NUMBER:client_port}\)[\s\t]+\[(%{NUMBER:process_id})\][\s\t]+(%{GREEDYDATA:application_name})[\s\t]+(%{USERNAME:username})[\s\t]+(%{WORD:db_name})[\s\t]+(?<session_id>%{BASE16NUM}.%{BASE16NUM})[\s\t]+(%{NUMBER:trasaction_id})[\s\t]+(ERROR:|FATAL:)[\s\t]+(%{GREEDYDATA:error_description}[\s\t]*)"
                    }
                    add_field => {
                        event_type => "SQL_ERROR"
                    }
                }
            }
        }

        if "sql_event" in [tags] or "sql_error_event" in [tags] {
            mutate {
                add_field => {
                    "log_type" => "sql"
                }
            }
        }

        mutate {
            add_field => {
                "serverHost" => "%{[host][name]}"
                "serverOS" => "%{[host][os][name]}"
                "serverIP" => "%{[@metadata][ip_address]}"
            }
        }

        if "_grokparsefailure" in [tags] {
            drop { }
        }

        yugabytedb_guardium_filter{}

        mutate {
            remove_tag => ["sql_event" , "sql_error_event"]
        }

        prune {
            whitelist_names => [ "GuardRecord" ]
        }
    }
}

output {
    stdout { codec => json }
}
