#/*
#Copyright 2023-24 IBM Inc. - All Rights Reserved.
#SPDX-License-Identifier: Apache-2.0
#*/

input {
  generator {
    lines => [
      '<AuditRecord><Audit_Type>1</Audit_Type><Session_Id>122166</Session_Id><StatementId>157</StatementId><EntryId>595</EntryId><Extended_Timestamp>2024-01-03T15:12:47.288741Z</Extended_Timestamp><DB_User>ADMIN</DB_User><OS_User>apurvabirajdar</OS_User><Userhost>Apurvas-MacBook-Pro.local</Userhost><OS_Process>21229</OS_Process><Terminal>unknown</Terminal><Instance_Number>0</Instance_Number><Action>44</Action><TransactionId>08001A007BBA0000</TransactionId><Returncode>0</Returncode><DBID>1678517840</DBID><Current_User>ADMIN</Current_User><Sql_Text>Create table OracleDB (DayId int,DayName varchar(50))</Sql_Text></AuditRecord>', #ValidLog
      '<AuditRecord><Audit_Type>1</Audit_Type><Session_Id>121823</Session_Id><StatementId>76</StatementId><EntryId>635</EntryId><Extended_Timestamp>2024-01-03T09:23:04.079928Z</Extended_Timestamp><DB_User>ADMIN</DB_User><OS_User>apurvabirajdar</OS_User><Userhost>Apurvas-MacBook-Pro.local</Userhost><OS_Process>7715</OS_Process><Terminal>unknown</Terminal><Instance_Number>0</Instance_Number><Object_Schema>ADMIN</Object_Schema><Object_Name>DEMO1</Object_Name><Action>12</Action><TransactionId>0000000000000000</TransactionId><Returncode>942</Returncode><Scn>37476446</Scn><DBID>1678517840</DBID><Current_User>ADMIN</Current_User><Sql_Text>DROP TABLE demo1</Sql_Text></AuditRecord>', #SQLERROR
      '<AuditRecord><Audit_Type>1</Audit_Type><Session_Id>122358</Session_Id><StatementId>1</StatementId><EntryId>1</EntryId><Extended_Timestamp>2024-01-03T17:18:45.538741Z</Extended_Timestamp><DB_User>BBBBB</DB_User><OS_User>apurvabirajdar</OS_User><Userhost>Apurvas-MacBook-Pro.local</Userhost><OS_Process>15787</OS_Process><Terminal>unknown</Terminal><Instance_Number>0</Instance_Number><Action>100</Action><TransactionId>0000000000000000</TransactionId><Returncode>1017</Returncode><Comment_Text>Authenticated by: DATABASE;AUTHENTICATED IDENTITY: BBBBB; Client address: (ADDRESS=(PROTOCOL=tcp)(HOST=49.156.71.123)(PORT=55984))</Comment_Text><DBID>1678517840</DBID><Current_User>BBBBB</Current_User></AuditRecord>', #loginFailed
      '<AuditRecord><Audit_Type>1</Audit_Type><Session_Id>112832</Session_Id><EntryId>12</EntryId><Extended_Timestamp>2023-12-18T13:08:16.902914Z</Extended_Timestamp><DB_User>ADMIN</DB_User><OS_User>apurvabirajdar</OS_User><Userhost>Apurvas-MacBook-Pro.local</Userhost><OS_Process>2761</OS_Process><Terminal>unknown</Terminal><Instance_Number>0</Instance_Number><Action>102</Action><Returncode>0</Returncode><DBID>1678517840</DBID>\n</AuditRecord>', #sql_text blank
      '<AuditRecord><Audit_Type>4</Audit_Type><Session_Id>4294967295</Session_Id><StatementId>2</StatementId><EntryId>4</EntryId><Extended_Timestamp>2023-12-18T19:27:55.087565Z</Extended_Timestamp><DB_User>/</DB_User><Ext_Name>rdsdb</Ext_Name><OS_User>rdsdb</OS_User><Userhost>ip-10-1-5-7</Userhost><OS_Process>8555</OS_Process><Instance_Number>0</Instance_Number><Returncode>0</Returncode><OSPrivilege>SYSDBA</OSPrivilege><DBID>1678517840</DBID><Current_User>SYS</Current_User>\n<Sql_Text>COMMIT</Sql_Text>\n</AuditRecord>' #system-generted
    ]
    count => 1
    type => "Oua"
    add_field => { log_group => ["/aws/rds/instance/database-2/audit"] }
    add_field => { "account_id" => "34682495****" }
  }
}


filter {
  if [type] == "Oua" {

    xml {
      source => "message"
      store_xml => false
      xpath => [
        "/AuditRecord/Audit_Type/text()", "Audit_Type",
        "/AuditRecord/Session_Id/text()", "Session_Id",
        "/AuditRecord/StatementId/text()", "StatementId",
        "/AuditRecord/EntryId/text()", "EntryId",
        "/AuditRecord/Extended_Timestamp/text()", "Extended_Timestamp", #thisisTimeStamp
        "/AuditRecord/DB_User/text()", "DB_User",        #this is DBUser
        "/AuditRecord/OS_User/text()", "OS_User",
        "/AuditRecord/Userhost/text()", "Userhost",   #this is clienIP or clientHostname
        "/AuditRecord/OS_Process/text()", "OS_Process",
        "/AuditRecord/Instance_Number/text()", "Instance_Number",
        "/AuditRecord/Object_Schema/text()", "Object_Schema",  #this is databaseName
        "/AuditRecord/Object_Name/text()", "Object_Name",       #this is tableName
        "/AuditRecord/Action/text()", "Action",
        "/AuditRecord/Returncode/text()", "Returncode",
        "/AuditRecord/Comment_Text/text()", "Comment_text", #this is to captureloginfailed.
        "/AuditRecord/Scn/text()", "Scn",
        "/AuditRecord/DBID/text()", "DBID",
        "/AuditRecord/Current_User/text()", "Current_User",
        "/AuditRecord/Sql_Bind/text()", "Sql_Bind",
        "/AuditRecord/Sql_Text/text()", "Sql_Text"
      ]
    }
       mutate {
                 add_field => { "Check_DB_User" => "%{DB_User}" }
                 add_field => { "Check_Sql_Text" => "%{Sql_Text}" }
                 add_field => { "Check_Comment_text" => "%{Comment_text}" }
              }


    if [Check_DB_User] == "RDSADMIN" or [Check_DB_User] == "SYS"
    or [Check_DB_User] == "/" or [Sql_Text] == "" or [Sql_Text] == "/" or (![Comment_text] and ![Sql_Text])
    {
      drop {}
    }

     # Clean up Sql_Text
       mutate {
         gsub => [
           "Sql_Text", ":\\\"SYS_B_([0-9]+)\\\"", ":\"SYS_B_\\1\""
         ]
       }

       # Clean up Sql_Bind
       grok {
           match => { "Sql_Bind" => "^ #1\(1\):: %{GREEDYDATA:cleaned_sql_bind}" }
         }
       mutate {
           replace => { "Sql_Bind" => "%{cleaned_sql_bind}" }
         }

       mutate { add_field => { "log_group" => "%{[cloudwatch_logs][log_group]}" } }

       grok { match => { "log_group" => "(?<data11>[^\/]*)\/(?<data12>[^\/]*)\/(?<data13>[^\/]*)\/(?<data14>[^\/]*)\/(?<instance>[^\/]*)\/(?<data15>[^\/]*)" } }


        #Build GuardRecord

        mutate {
                      add_field =>
                      {
                        "[GuardRecord][accessor][serverHostName]" => "%{account_id}_%{instance}"
                        "[GuardRecord][accessor][dbProtocol]" => "ORACLE"
                        "[GuardRecord][accessor][dataType]" => "TEXT"
                        "[GuardRecord][accessor][language]" => "ORACLE"
                        "[GuardRecord][accessor][serverType]" => "Oracle"
                        "[GuardRecord][dbName]" => "NA"
                        "[GuardRecord][time][minOffsetFromGMT]" => "0"
                        "[GuardRecord][time][minDst]" => "0"
                        "[GuardRecord][sessionLocator][clientPort]" => "-1"
                        "[GuardRecord][sessionLocator][serverIp]" => "0.0.0.0"
                        "[GuardRecord][sessionLocator][isIpv6]" => "false"
                        "[GuardRecord][sessionLocator][serverPort]" => "-1"
                        "[GuardRecord][accessor][dbUser]" => "NA"
                        "[GuardRecord][accessor][dbProtocolVersion]" => ""
                        "[GuardRecord][accessor][clientMac]" => ""
                        "[GuardRecord][accessor][serverOs]" => ""
                        "[GuardRecord][accessor][clientOs]" => ""
                        "[GuardRecord][accessor][osUser]" => ""
                        "[GuardRecord][appUserName]" =>  ""

                      }
                }

       ruby { code => 'event.set("[GuardRecord][sessionLocator][clientIpv6]", nil)' }
       ruby { code => 'event.set("[GuardRecord][sessionLocator][serverIpv6]", nil)' }

           mutate {
                add_field => { "check_action_code" => "%{Action}" }
                add_field => { "check_return_code" => "%{Returncode}" }

              }


       if [check_return_code] != "0"
        {
            if  [check_action_code] == "12"
     	    {
                  mutate { add_field => { "[GuardRecord][exception][exceptionTypeId]" => "SQL_ERROR" }}
     			  mutate { replace => { "[GuardRecord][exception][sqlString]" => "%{Sql_Text}" }}
     			  mutate { replace => { "[GuardRecord][exception][description]" => "SQL_ERROR" }}
     			  ruby { code => 'event.set("[GuardRecord][data]", nil)' }

             }
            else
            {
                mutate { add_field => { "[GuardRecord][exception][exceptionTypeId]" => "LOGIN_FAILED" }}
                mutate { replace => { "[GuardRecord][exception][sqlString]" => "%{Comment_text}" }}
                mutate { replace => { "[GuardRecord][exception][description]" => "LOGIN_FAILED" }}
                ruby { code => 'event.set("[GuardRecord][data]", nil)' }
          	}
        }
      else
      {
                ruby { code => 'event.set("[GuardRecord][data][construct]", nil)' }
     			mutate { add_field => { "[GuardRecord][data][originalSqlCommand]" => "%{Sql_Text}" }}
     			ruby { code => 'event.set("[GuardRecord][exception]", nil)' }

      }


       if [Session_Id]{
                        mutate { add_field => { "[GuardRecord][sessionId]" => "%{Session_Id}" }}
                    }

       if [Object_Schema]{
                         mutate { replace => { "[GuardRecord][dbName]" => "%{account_id}:%{instance}:%{Object_Schema}" }}
                         mutate { replace  => { "[GuardRecord][accessor][serviceName]" => "%{account_id}:%{instance}:%{Object_Schema}" }}

                       }
      if[DB_User]
      {
        mutate { replace => { "[GuardRecord][accessor][dbUser]" => "%{DB_User}" }}
      }


    if [Userhost] {
    mutate {
    add_field => { "[GuardRecord][accessor][clientHostName]" => "NA" }
    add_field => { "[GuardRecord][sessionLocator][clientIp]" => "0.0.0.0" }
    }
      grok {
        match => { "Userhost" => "(?:%{WORD}[-_])?(?:%{IP:myclientIp}|%{HOSTNAME:myclientHostName})" }
      }
      if [myclientHostName] {
        mutate {
          replace => { "[GuardRecord][accessor][clientHostName]" => "%{myclientHostName}"  }
        }
      } else {
        mutate {
          replace => { "[GuardRecord][sessionLocator][clientIp]" => "%{myclientIp}" }
        }
      }
    }

    # Date conversion
            if [Extended_Timestamp] {
                date {
                    match => ["[Extended_Timestamp][0]", "ISO8601"]
                    target => "new_timeStamp"
                }
                ruby {
                    code => '
                        if event.get("[new_timeStamp]")
                            event.set("[GuardRecord][time][timestamp]", event.get("[new_timeStamp]").time.to_i * 1000)
                        else
                            event.tag("timestamp_missing_error")
                        end
                    '
                }
            }


    # Remove unnecessary fields
    prune {
                   whitelist_names => [ "message","GuardRecord"]
          }
    mutate {
                    convert => { "[GuardRcecord]" => "string" }
           }
    json_encode {
                    source => "[GuardRecord]"
                }
  }
}

output {
  stdout {
    codec => rubydebug
  }
}