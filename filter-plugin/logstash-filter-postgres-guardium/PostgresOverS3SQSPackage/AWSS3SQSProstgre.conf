input {
      s3_sqs {
        queue_url => "<queue_url>"
        region => "<region>"
        access_key_id => "<access_key_id>"
        secret_access_key => "<secret_access_key>"
        role_arn => "<role_arn>" # Leave empty if not using role-based access
        max_messages => <max_messages>
        wait_time => <wait_time> # Must be >= 0 and <= 20,
        polling_frequency => <polling_frequency>
        type => "<type>"
        add_field => {
            "account_id" => "<Enter aws account id>"
            "instance_name" => "<Enter instance name>"
        }
      }
}

filter{

	if [type] == "PostgresS3SQS" {

	  json {
	    source => "message"
	    target => "parsed_message"
	    remove_field => ["message"]
	  }

	  # Drop known noise patterns
	  if [parsed_message][message] =~ /(pg_sleep|export_postgres_logs_to_s3|cron\.job_run_details|create_foreign_table_for_log_file|logs.postgres_logs|public\.list_postgres_log_files|information_schema\.tables|aws_s3\.query_export_to_s3)/ {
	    drop { }
	  }

	  # Drop ALTER/CREATE/CREATE FOREIGN TABLE statements on postgres_logs_<timestamp>
	  if [parsed_message][message] =~ /((ALTER|CREATE(\s+FOREIGN)?)\s+TABLE)\s+postgres_logs_\d{8}_\d{4}/ {
	    drop { }
	  }

	  # Sanitize multiline and quote issues
	  mutate {
	    gsub => [
	      "[parsed_message][message]", "\n", "",
	      "[parsed_message][message]", "Â¶", " ",
	      "[parsed_message][message]", '\\"', '"'
	    ]
	  }

	  # Promote nested parsed_message.message to top-level for grok
	  mutate {
	    add_field => {
	      "log_message" => "%{[parsed_message][message]}"
	    }
	  }

	  grok {
	    match => {
	      "log_message" => [
	        # Match structured AUDIT logs
	        'AUDIT: %{WORD:audit_level},%{INT:session_id},%{INT:transaction_id},%{WORD:operation_type},%{DATA:command},%{DATA:object_type},%{DATA:object_name},%{GREEDYDATA:full_sql_query},%{GREEDYDATA:details}',

	        # Catch-all error message fallback
	        '%{GREEDYDATA:ErrorMessage}'
	      ]
	    }
	    remove_field => ["log_message"]
	  }

	  # Drop events that couldn't be parsed by grok
	  if "_grokparsefailure" in [tags] {
	    drop { }
	  }

	  # Trim quotes from SQL query if it exists
	  mutate {
	    gsub => [
	      "full_sql_query", '^\"', '',
	      "full_sql_query", '\"$', ''
	    ]
	  }

	  # Call your custom Guardium plugin
	  s3sqs_postgresql_guardium_plugin_filter { }

	  # Retain only processed GuardRecord
	  prune {
	    whitelist_names => ["GuardRecord"]
	  }

	}

}